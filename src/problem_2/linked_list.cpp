#include "linked_list.h"
#include <vector>
template<class T>
void LinkedList<T>::push_front(const T &value) {
    auto *K = new ListNode<T>;
    K->next = head;
    K->val = value;
    head = K;
    num_of_element += 1;
    /*
     * TODO: homework
     */
}

template<class T>
void LinkedList<T>::push_back(const T &value) {
    ListNode<T> *new_node = new ListNode(value);
    new_node->next = nullptr;
    ListNode<T> *K = head;
    while(true){
        if(K->next == nullptr) break;
        K = K->next;
    }
    K->next = new_node;
    num_of_element += 1;
    /*
     * TODO: homework
     */
}

template<class T>
void LinkedList<T>::pop_back() {
    ListNode<T> *A = head;
    ListNode<T> *toDel = head;
    if(head->next == nullptr){
        head = NULL;
        delete[] A;
        delete[] toDel;
        return;
    }
    while(true){
        if(A->next->next == nullptr){
            break;
        }
        A = A->next;
    }
    toDel = A->next;
    A->next = nullptr;
    delete[] toDel;
    /*
     * TODO: homework
     */
}

template<class T>
void LinkedList<T>::pop_front() {
    ListNode<T> *toDel = head;
    head = head->next;
    delete[] toDel;
    /*
     * TODO: homework
     */
}

template<class T>
void LinkedList<T>::remove(T &val) {
    ListNode<T> *toDel = head;
    ListNode<T> *A = head;
    while(true){
        if(A->next == nullptr) return;
        if(A->next->val == val) break;
        A = A->next;
    }
    toDel = A->next;
    if(toDel->next == nullptr){
        A->next = nullptr;
        delete[] toDel;
        return;
    }
    A->next = A->next->next;
    delete[] toDel;
    /*
     * TODO: homework
     */
}

//basic quicksort alg generated by AI
void quicksort(std::vector<int>& arr, int start, int end) {
    if (start >= end) {
        return;
    }
    int pivot = arr[start];
    int i = start, j = end;
    while (i <= j) {
        while (arr[i] < pivot) {
            i++;
        }
        while (arr[j] > pivot) {
            j--;
        }
        if (i <= j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
    if (start < j) {
        quicksort(arr, start, j);
    }
    if (i < end) {
        quicksort(arr, i, end);
    }
}


/*
 * merge in ascending order
 */
template<class T>
void LinkedList<T>::merge(const List<T> &ot) {
    int size = this->num_of_element + ot.size() - 1;
    ListNode<T> C = head->next;
    std::vector<int> combine;
    for(int i = 0; i < size; i++){
        if(i < ot.size() - 1){
            combine.push_back(ot[i]);
        }
        else{
            combine.push_back(C.val);
            C = C.next;
        }
    }
    quicksort(combine, 0, size);
    auto *K = new ListNode<T>;
    ListNode<T> *U = K;
    for(int i = 0; i < size; i++){
        U->next = new ListNode<T>;
        U = U->next;
        U->val = combine[i];
        U->next = nullptr;
    }
    head = K;
    delete K;
    /*
     * TODO: homework
     */
}



template<class T>
void LinkedList<T>::reverse_iterative() {
    int i = 0;
    auto *C = new ListNode<T>;
    ListNode<T> *B = C;
    int *G[this->num_of_element];
    for(; head->next != nullptr; head = head->next){
        G[i] = head->val;
        i++;
    }
    B->next = new ListNode<T>;
    B = B->next;
    for(int a = 0; a < i; a++){
        B->val = G[a];
        B->next = new ListNode<T>;
        B = B->next;
        B->next = nullptr;
    }
    head = C;
    /*
     * TODO: homework
     */
}